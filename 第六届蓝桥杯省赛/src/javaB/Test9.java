package javaB;

import java.util.Scanner;

/**垒骰子
	赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。
	经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！
	我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。
	假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 atm想计算一下有多少种不同的可能的垒骰子方式。
	两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。
	由于方案数可能过多，请输出模 10^9 + 7 的结果。
	不要小看了 atm 的骰子数量哦～
	「输入格式」
	第一行两个整数 n m
	n表示骰子数目
	接下来 m 行，每行两个整数 a b ，表示 a 和 b 不能紧贴在一起。
	「输出格式」
	一行一个数，表示答案模 10^9 + 7 的结果。
	「样例输入」
	2 1
	1 2
	「样例输出」
	544
	「数据范围」
	对于 30% 的数据：n <= 5
	对于 60% 的数据：n <= 100
	对于 100% 的数据：0 < n <= 10^9, m <= 36
 * 
 * @author 49944
 *
 */
public class Test9 {
/**                              c = a/b;   r = a-c*b;
 *                                    归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
                                                                                                 当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。
 * @param args
 */
	public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(); //骰子数目
        int m = scan.nextInt(); //m行
        int[][] array = new int[m][2]; //保存了m组不能紧贴在一起的数字
        
        for(int i=0; i<2*m; i++){
        	for(int j=0; j<2; j++){
        		array[i][j] = scan.nextInt(); 
        	}
        }
        
        
	}

}
